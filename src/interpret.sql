

create table service (
  id int generated by default as identity primary key,

  "type" service_type not null,

  -- If "type" = 'machine'
  machine_type machine_type,
  machine int not null,
  state int references state_node not null,

  -- If "type" = 'external'
  external_service external_service_type,

  parent int references service,
  invoked_through int references invocation,
  created_at timestamptz default now() not null,
  foreign key (machine, machine_type) references machine (id, "type")
);

create table internal_event_queue (
  event int references event,
  service int references service,
  handled_at timestamptz default now() not null,
  created_at timestamptz default now() not null
);


create function send_notification() returns trigger language plpgsql as $f$
declare
  _channel_name text := TG_ARGV[0];
  _types action_type[];
begin
  select array_agg(distinct "type")
    into _types
    from new_jobs
         join action
              on action.id = new_jobs.action;

  raise notice 'Channel: % Types: %', _channel_name, _types;

  perform pg_notify(_channel_name, "type"::text) from unnest(_types) _ ("type");

  return null;
end $f$;

create type job_state as enum ('queued', 'processing', 'done', 'error');


-- create table external_service (
--   id int generated by default as identity primary key,
--   parent int references service not null,
--   invocation int references invocation not null,
--   state job_state default 'queued' not null,
--   created_at timestamptz default now() not null,
--   handled_at timestamptz
-- );


create table invocation_done_event (
  id int references event primary key,
  child int references service not null
);

create table invocation_error_event (
  id int references event primary key,
  child int references service not null
);

create table action_job (
  id int generated by default as identity primary key,
  action int references action not null,
  service int references service not null,
  state job_state default 'queued' not null,
  created_at timestamptz default now() not null
);

create table action_job_log (
  job int references action_job on delete cascade,
  created_at timestamptz default now() not null,
  newstate text
);

create trigger notify_workers
  after insert on action_job
  referencing new table as new_jobs
  for each statement
  execute function send_notification('action_jobs');


create table transition_log (
  service int references service,
  transition int references transition,
  created_at timestamptz default now() not null 
);


create table event_queue (
  service int references service,
  event int references event,
  handled_at timestamptz,
  created_at timestamptz default now() not null
);

create function run_mainloop() returns trigger language plpgsql as $f$
declare
  _service_id int;
begin

  for _service_id in (select distinct service from new_events) loop
  
    call mainloop(_service_id);

  end loop;

  return null;
end $f$;

create trigger run
  after insert on event_queue
  referencing new table as new_events
  for each statement
  execute function run_mainloop();
  

-- Add an event to a service's event queue
create function send_event(event_id int, service_id int) returns void language sql as $$
  insert into event_queue (event, service) values (event_id, service_id)
$$;




create function create_service(
  machine int, 
  context jsonb default null,
  out _service_id int
)
returns int language plpgsql as $$
declare
  _initial_state_id int;
  _type machine_type;
  _initial_transition_id int;
begin
  select "type",
         state
    into _type,
         _initial_state_id
    from machine
   where id = $1;

  insert into service (machine, "type", machine_type, state)
  select $1, 'machine', _type, _initial_state_id
  returning id into _service_id;

  call mainloop(_service_id);
end $$;



create function select_transition(
  service_id int,
  event_id int
)
returns int language plpgsql as $f$
declare
  _transition transition;  
  _current state_node;
  _event_type event_type;
begin
  select *
    into _current
    from state_node
   where exists (select from service where id = $1 and state = state_node.id);

  select "type"
    into _event_type
    from event
   where id = $2;

  for _transition in (
      select transition.*
        from event_mapping
             join transition
                  on transition.id = event_mapping.transition
       where event_type = _event_type
             and exists (select
                           from state_node
                          where machine = _current.machine
                                and path @> _current.path
                                and state_node.id = event_mapping.state)
    order by event_mapping.order
  ) loop

    raise notice 'Found a transition for event %', _event_type;

    if (
      select coalesce(bool_and(condition_match(service_id, id)), true)
        from guard
       where transition = _transition.id
    ) then

      raise notice 'Conditions match';

    else
      raise notice 'Conditions do not match';
    end if;

    return _transition.id;

  end loop;

  return null;
end $f$;



create procedure descend(
  service_id int
)
language plpgsql as $f$
declare
  _current_state int;
  _current_path ltree;
  _is_compound bool;
  _atomic_state_id int;
  _entry_actions int[];
begin

  select "type" = 'compound',
         id
    into _is_compound,
         _current_state
    from state_node
   where exists (select from service where id = descend.service_id and state = state_node.id);

  if not _is_compound then
    return;
  end if;

  with recursive t(state_id, depth) as (
    select _current_state, 0::int

    union all

    select initial, depth + 1
      from t
           join state_node s
                on s.id = t.state_id
     where "type" = 'compound'
  ),
  entry_actions as (
    select array_agg(action)
      from t
           join onentry_action onentry
                on onentry.state = t.state_id
  )

  select (select state_id from t order by depth desc limit 1),

         (select * from entry_actions)

         --(select jsonb_agg(to_jsonb(t.*)) from t)

    into _atomic_state_id,
         _entry_actions;

  update service
     set state = _atomic_state_id
   where id = descend.service_id;
  
  insert into action_job (service, action)
  select service_id,
         action
    from unnest(_entry_actions) _ (action);

end $f$;


create procedure mainloop(
  service_id int
)
language plpgsql as $f$
declare
  _running bool := true;
  _enabled_transition int := null;
  _macrostep_done bool;
  _internal_event_id int;
  _event_id int;
  _event_type event_type;
begin

  call descend(service_id);

  _enabled_transition := select_eventless_transition($1);

  while _enabled_transition is not null loop

    call do_transition(service_id, _enabled_transition);
    _enabled_transition := select_eventless_transition($1);
  end loop;

    select event
      into _event_id
      from event_queue
     where service = $1
           and handled_at is null
  order by created_at
     limit 1;

  if _event_id is null then
    return;
  end if;

  select "type" into _event_type from event where id = _event_id;


  update event_queue
     set handled_at = now()
   where event = _event_id
         and service = mainloop.service_id;

  _enabled_transition := select_transition(service_id, _event_id);    


  if _enabled_transition is not null then
    call do_transition(mainloop.service_id, _enabled_transition);
  end if;
end $f$;

create function debug_transition(int) returns text language sql stable as $$
  select format(
           '<Transition id=%s to=%s machine=%s>',
           transition.id,
           target.path,
           machine
         )
    from transition
         join state_node target
              on target.id = transition.target
   where transition.id = $1
$$;



create table states_to_invoke (
  service int references service,
  state int references state_node,
  primary key (service, state)
);



create function at_atomic_state(service_id int) returns bool language sql stable as $f$
  select 'atomic' = "type"
    from state_node
   where exists (select from service where id = $1 and state = state_node.id)
$f$;

create procedure do_transition(
  service_id int,
  transition_id int
)
language plpgsql as $f$
declare
  _machine_id int;

  _current_path ltree;
  _current_state_id int;

  _target_path ltree;
  _target_state_id int;  

  _states_to_enter ltree[];
  _states_to_exit ltree[];
  _lca ltree;

  _entry_actions int[];
  _exit_actions int[];
begin
  select machine,
         state
    into _machine_id,
         _current_state_id
    from service
   where id = service_id;

  select path
    into _current_path 
    from state_node
   where id = _current_state_id;

  select target
    into _target_state_id
    from transition
   where id = transition_id;

  select path
    into _target_path
    from state_node
   where id = _target_state_id;

  _lca := longest_common_prefix(_current_path, _target_path);

  select array_agg(path),
         array_agg(action) filter (where action is not null)
    into _states_to_exit,
         _exit_actions
    from state_node
         left join onexit_action
                   on onexit_action.state = state_node.id
   where machine = _machine_id
         and _lca @> path
         and _current_path <@ path
         and _lca <> path;

  select array_agg(path),
         array_agg(onentry_action.action) filter (where action is not null)

    into _states_to_enter,
         _entry_actions

    from state_node
         left join onentry_action
                   on onentry_action.state = state_node.id
   where machine = _machine_id
         and _lca @> path
         and _target_path <@ path
         and _lca <> path;

  -- Queue entry actions
  insert into action_job (service, action)
  select service_id,
         action_id
    from unnest(_entry_actions) _ (action_id);

  -- Queue transition actions
  insert into action_job (service, action)
  select do_transition.service_id,
         action
    from transition_action
   where transition = do_transition.transition_id;

  insert into action_job (service, action)
  select do_transition.service_id,
         action
    from unnest(_exit_actions) _ (action);

  raise notice 'Transition actions: %',
  (select array_agg("type")
     from action
    where exists (select from transition_action where transition = transition_id and action = action.id));

  update service
     set state = _target_state_id
   where id = do_transition.service_id;

  insert into transition_log (service, transition)
  values (service_id, transition_id);

  raise notice 'States to enter: %', _states_to_enter;
  raise notice 'Entry actions: %', _entry_actions;
  raise notice 'Exit actions: %', _exit_actions;

end $f$;


create function condition_match(
  service_id int,
  guard_id int
)
returns bool language plpgsql as $$
declare
  _type condition_type;
  _table_name text;
  _eval regproc;
  _has_params bool;
  _params jsonb := null;
  _result bool;
begin
  -- TODO Decide if this makes sense
  if service_id is null or guard_id is null then
    return null;
  end if;

  select "type"
    into _type
    from guard
   where id = guard_id;

  select has_params,
         eval
    into _has_params,
         _eval
    from condition_info
   where id = _type;

  if _has_params then 

    _table_name := _type || '_guard';

    execute format('select to_jsonb(%1$I) from %1$I where id = %L', _table_name, guard_id)
     into _params;
  end if;

  execute format('select %I(%L)', _eval, _params)
    using _params
     into _result;

  return _result;
end $$ stable;

create function select_eventless_transition(service int)
returns int language sql stable as $f$
  with _current_state as (
    select path,
           machine
      from state_node
     where exists (select from service where id = $1 and state_node.id = state)
  )
     select eventless.transition
       from state_node source
            join eventless
                 on eventless.state = source.id
            left join guard
                      on guard.transition = eventless.transition

     where source.machine  = (select machine from _current_state)
            and source.path @> (select path from _current_state)

  group by eventless.transition,
           source.path,
           eventless.order
           having coalesce(bool_and(condition_match(service, guard.id)), true)

  order by nlevel(source.path) desc,
           eventless.order

     limit 1
$f$;
